From a3069f61f2c29390636e9c4ccdb5ab232e12e095 Mon Sep 17 00:00:00 2001
From: UtsavBalar1231 <utsavbalar1231@gmail.com>
Date: Sat, 29 Jun 2024 18:48:11 +0530
Subject: [PATCH] wm8960-rpi-cm4

Change-Id: I176c4dc4f3035f96e8ad04c4ad75a04b41c38614
Signed-off-by: UtsavBalar1231 <utsavbalar1231@gmail.com>
---
 arch/arm/boot/dts/bcm2711-rpi-cm4.dts |  51 ++
 sound/soc/codecs/Makefile             |   2 +
 sound/soc/codecs/wm8960-soundcard.c   | 747 ++++++++++++++++++++++++++
 sound/soc/codecs/wm8960.c             | 372 +++++++------
 sound/soc/codecs/wm8960.h             |   5 +-
 5 files changed, 1003 insertions(+), 174 deletions(-)
 create mode 100644 sound/soc/codecs/wm8960-soundcard.c

diff --git a/arch/arm/boot/dts/bcm2711-rpi-cm4.dts b/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
index 471d073da02c..6c7aabd26c06 100644
--- a/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
+++ b/arch/arm/boot/dts/bcm2711-rpi-cm4.dts
@@ -13,6 +13,12 @@ chosen {
 		stdout-path = "serial1:115200n8";
 	};
 
+	wm8960_mclk: wm8960_mclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <12288000>;
+	};
+
 	leds {
 		led-act {
 			gpios = <&gpio 42 GPIO_ACTIVE_HIGH>;
@@ -508,11 +514,21 @@ &i2c1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2c1_pins>;
 	clock-frequency = <100000>;
+	status = "okay";
+
+	wm8960: wm8960@1a {
+		compatible = "wlf,wm8960";
+		reg = <0x1a>;
+		#sound-dai-cells = <0>;
+		AVDD-supply = <&vdd_5v0_reg>;
+		DVDD-supply = <&vdd_3v3_reg>;
+	};
 };
 
 &i2s {
 	pinctrl-names = "default";
 	pinctrl-0 = <&i2s_pins>;
+	status = "okay";
 };
 
 // =============================================
@@ -603,3 +619,38 @@ __overrides__ {
 				  <&cam1_reg>,"gpio:0=", <&gpio>;
 	};
 };
+
+&sound {
+	slave_overlay: wm8960-soundcard {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "wm8960-soundcard";
+		status = "okay";
+
+		simple-audio-card,widgets =
+			"Microphone", "Mic Jack",
+			"Line", "Line In",
+			"Line", "Line Out",
+			"Speaker", "Speaker",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"Headphone Jack", "HP_L",
+			"Headphone Jack", "HP_R",
+			"Speaker", "SPK_LP",
+			"Speaker", "SPK_LN",
+			"LINPUT1", "Mic Jack",
+			"LINPUT3", "Mic Jack",
+			"RINPUT1", "Mic Jack",
+			"RINPUT2", "Mic Jack";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s>;
+		};
+
+		dailink0_slave: simple-audio-card,codec {
+			sound-dai = <&wm8960>;
+			clocks = <&wm8960_mclk>;
+			clock-names = "mclk";
+		};
+	};
+};
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 58493a2b0a6b..824bffdcd784 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -669,3 +669,5 @@ obj-$(CONFIG_SND_SOC_LPASS_TX_MACRO)	+= snd-soc-lpass-tx-macro.o
 
 # Mux
 obj-$(CONFIG_SND_SOC_SIMPLE_MUX)	+= snd-soc-simple-mux.o
+
+obj-m += wm8960-soundcard.o
diff --git a/sound/soc/codecs/wm8960-soundcard.c b/sound/soc/codecs/wm8960-soundcard.c
new file mode 100644
index 000000000000..a5e293f5bbfb
--- /dev/null
+++ b/sound/soc/codecs/wm8960-soundcard.c
@@ -0,0 +1,747 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// ASoC simple sound card support
+//
+// Copyright (C) 2012 Renesas Solutions Corp.
+// Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <sound/simple_card.h>
+#include <sound/soc-dai.h>
+#include <sound/soc.h>
+
+#define DPCM_SELECTABLE 1
+
+#define DAI "sound-dai"
+#define CELL "#sound-dai-cells"
+#define PREFIX "simple-audio-card,"
+
+static const struct snd_soc_ops simple_ops = {
+	.startup = asoc_simple_startup,
+	.shutdown = asoc_simple_shutdown,
+	.hw_params = asoc_simple_hw_params,
+};
+
+static int asoc_simple_parse_platform(struct device_node *node,
+				      struct snd_soc_dai_link_component *dlc)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+
+	/* dai_name is not required and may not exist for plat component */
+
+	dlc->of_node = args.np;
+
+	return 0;
+}
+
+static int asoc_simple_parse_dai(struct device_node *node,
+				 struct snd_soc_dai_link_component *dlc,
+				 int *is_single_link)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	/*
+	 * Get node via "sound-dai = <&phandle port>"
+	 * it will be used as xxx_of_node on soc_bind_dai_link()
+	 */
+	ret = of_parse_phandle_with_args(node, DAI, CELL, 0, &args);
+	if (ret)
+		return ret;
+
+	/*
+	 * FIXME
+	 *
+	 * Here, dlc->dai_name is pointer to CPU/Codec DAI name.
+	 * If user unbinded CPU or Codec driver, but not for Sound Card,
+	 * dlc->dai_name is keeping unbinded CPU or Codec
+	 * driver's pointer.
+	 *
+	 * If user re-bind CPU or Codec driver again, ALSA SoC will try
+	 * to rebind Card via snd_soc_try_rebind_card(), but because of
+	 * above reason, it might can't bind Sound Card.
+	 * Because Sound Card is pointing to released dai_name pointer.
+	 *
+	 * To avoid this rebind Card issue,
+	 * 1) It needs to alloc memory to keep dai_name eventhough
+	 *    CPU or Codec driver was unbinded, or
+	 * 2) user need to rebind Sound Card everytime
+	 *    if he unbinded CPU or Codec.
+	 */
+	ret = snd_soc_of_get_dai_name(node, &dlc->dai_name);
+	if (ret < 0)
+		return ret;
+
+	dlc->of_node = args.np;
+
+	if (is_single_link)
+		*is_single_link = !args.args_count;
+
+	return 0;
+}
+
+static void simple_parse_convert(struct device *dev, struct device_node *np,
+				 struct asoc_simple_data *adata)
+{
+	struct device_node *top = dev->of_node;
+	struct device_node *node = of_get_parent(np);
+
+	asoc_simple_parse_convert(top, PREFIX, adata);
+	asoc_simple_parse_convert(node, PREFIX, adata);
+	asoc_simple_parse_convert(node, NULL, adata);
+	asoc_simple_parse_convert(np, NULL, adata);
+
+	of_node_put(node);
+}
+
+static void simple_parse_mclk_fs(struct device_node *top,
+				 struct device_node *np,
+				 struct simple_dai_props *props, char *prefix)
+{
+	struct device_node *node = of_get_parent(np);
+	char prop[128];
+
+	snprintf(prop, sizeof(prop), "%smclk-fs", PREFIX);
+	of_property_read_u32(top, prop, &props->mclk_fs);
+
+	snprintf(prop, sizeof(prop), "%smclk-fs", prefix);
+	of_property_read_u32(node, prop, &props->mclk_fs);
+	of_property_read_u32(np, prop, &props->mclk_fs);
+
+	of_node_put(node);
+}
+
+static int simple_parse_node(struct asoc_simple_priv *priv,
+			     struct device_node *np, struct link_info *li,
+			     char *prefix, int *cpu)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *top = dev->of_node;
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, li->link);
+	struct snd_soc_dai_link_component *dlc;
+	struct asoc_simple_dai *dai;
+	int ret;
+
+	if (cpu) {
+		dlc = asoc_link_to_cpu(dai_link, 0);
+		dai = simple_props_to_dai_cpu(dai_props, 0);
+	} else {
+		dlc = asoc_link_to_codec(dai_link, 0);
+		dai = simple_props_to_dai_codec(dai_props, 0);
+	}
+
+	simple_parse_mclk_fs(top, np, dai_props, prefix);
+
+	ret = asoc_simple_parse_dai(np, dlc, cpu);
+	if (ret)
+		return ret;
+
+	ret = asoc_simple_parse_clk(dev, np, dai, dlc);
+	if (ret)
+		return ret;
+
+	ret = asoc_simple_parse_tdm(np, dai);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int simple_link_init(struct asoc_simple_priv *priv,
+			    struct device_node *node, struct device_node *codec,
+			    struct link_info *li, char *prefix, char *name)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);
+	int ret;
+
+	ret = asoc_simple_parse_daifmt(dev, node, codec, prefix,
+				       &dai_link->dai_fmt);
+	if (ret < 0)
+		return 0;
+
+	dai_link->init = asoc_simple_dai_init;
+	dai_link->ops = &simple_ops;
+
+	return asoc_simple_set_dailink_name(dev, dai_link, name);
+}
+
+static int simple_dai_link_of_dpcm(struct asoc_simple_priv *priv,
+				   struct device_node *np,
+				   struct device_node *codec,
+				   struct link_info *li, bool is_top)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);
+	struct simple_dai_props *dai_props =
+		simple_priv_to_props(priv, li->link);
+	struct device_node *top = dev->of_node;
+	struct device_node *node = of_get_parent(np);
+	char *prefix = "";
+	char dai_name[64];
+	int ret;
+
+	dev_dbg(dev, "link_of DPCM (%pOF)\n", np);
+
+	/* For single DAI link & old style of DT node */
+	if (is_top)
+		prefix = PREFIX;
+
+	if (li->cpu) {
+		struct snd_soc_dai_link_component *cpus =
+			asoc_link_to_cpu(dai_link, 0);
+		struct snd_soc_dai_link_component *platforms =
+			asoc_link_to_platform(dai_link, 0);
+		int is_single_links = 0;
+
+		/* Codec is dummy */
+
+		/* FE settings */
+		dai_link->dynamic = 1;
+		dai_link->dpcm_merged_format = 1;
+
+		ret = simple_parse_node(priv, np, li, prefix, &is_single_links);
+		if (ret < 0)
+			goto out_put_node;
+
+		snprintf(dai_name, sizeof(dai_name), "fe.%s", cpus->dai_name);
+
+		asoc_simple_canonicalize_cpu(cpus, is_single_links);
+		asoc_simple_canonicalize_platform(platforms, cpus);
+	} else {
+		struct snd_soc_dai_link_component *codecs =
+			asoc_link_to_codec(dai_link, 0);
+		struct snd_soc_codec_conf *cconf;
+
+		/* CPU is dummy */
+
+		/* BE settings */
+		dai_link->no_pcm = 1;
+		dai_link->be_hw_params_fixup = asoc_simple_be_hw_params_fixup;
+
+		cconf = simple_props_to_codec_conf(dai_props, 0);
+
+		ret = simple_parse_node(priv, np, li, prefix, NULL);
+		if (ret < 0)
+			goto out_put_node;
+
+		snprintf(dai_name, sizeof(dai_name), "be.%s", codecs->dai_name);
+
+		/* check "prefix" from top node */
+		snd_soc_of_parse_node_prefix(top, cconf, codecs->of_node,
+					     PREFIX "prefix");
+		snd_soc_of_parse_node_prefix(node, cconf, codecs->of_node,
+					     "prefix");
+		snd_soc_of_parse_node_prefix(np, cconf, codecs->of_node,
+					     "prefix");
+	}
+
+	simple_parse_convert(dev, np, &dai_props->adata);
+
+	snd_soc_dai_link_set_capabilities(dai_link);
+
+	ret = simple_link_init(priv, node, codec, li, prefix, dai_name);
+
+out_put_node:
+	li->link++;
+
+	of_node_put(node);
+	return ret;
+}
+
+static int simple_dai_link_of(struct asoc_simple_priv *priv,
+			      struct device_node *np, struct device_node *codec,
+			      struct link_info *li, bool is_top)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct snd_soc_dai_link *dai_link = simple_priv_to_link(priv, li->link);
+	struct snd_soc_dai_link_component *cpus = asoc_link_to_cpu(dai_link, 0);
+	struct snd_soc_dai_link_component *codecs =
+		asoc_link_to_codec(dai_link, 0);
+	struct snd_soc_dai_link_component *platforms =
+		asoc_link_to_platform(dai_link, 0);
+	struct device_node *cpu = NULL;
+	struct device_node *node = NULL;
+	struct device_node *plat = NULL;
+	char dai_name[64];
+	char prop[128];
+	char *prefix = "";
+	int ret, single_cpu = 0;
+
+	cpu = np;
+	node = of_get_parent(np);
+
+	dev_dbg(dev, "link_of (%pOF)\n", node);
+
+	/* For single DAI link & old style of DT node */
+	if (is_top)
+		prefix = PREFIX;
+
+	snprintf(prop, sizeof(prop), "%splat", prefix);
+	plat = of_get_child_by_name(node, prop);
+
+	ret = simple_parse_node(priv, cpu, li, prefix, &single_cpu);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = simple_parse_node(priv, codec, li, prefix, NULL);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	ret = asoc_simple_parse_platform(plat, platforms);
+	if (ret < 0)
+		goto dai_link_of_err;
+
+	snprintf(dai_name, sizeof(dai_name), "%s-%s", cpus->dai_name,
+		 codecs->dai_name);
+
+	asoc_simple_canonicalize_cpu(cpus, single_cpu);
+	asoc_simple_canonicalize_platform(platforms, cpus);
+
+	ret = simple_link_init(priv, node, codec, li, prefix, dai_name);
+
+dai_link_of_err:
+	of_node_put(plat);
+	of_node_put(node);
+
+	li->link++;
+
+	return ret;
+}
+
+static int __simple_for_each_link(
+	struct asoc_simple_priv *priv, struct link_info *li,
+	int (*func_noml)(struct asoc_simple_priv *priv, struct device_node *np,
+			 struct device_node *codec, struct link_info *li,
+			 bool is_top),
+	int (*func_dpcm)(struct asoc_simple_priv *priv, struct device_node *np,
+			 struct device_node *codec, struct link_info *li,
+			 bool is_top))
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *top = dev->of_node;
+	struct device_node *node;
+	uintptr_t dpcm_selectable = (uintptr_t)of_device_get_match_data(dev);
+	bool is_top = 0;
+	int ret = 0;
+
+	/* Check if it has dai-link */
+	node = of_get_child_by_name(top, PREFIX "dai-link");
+	if (!node) {
+		node = of_node_get(top);
+		is_top = 1;
+	}
+
+	/* loop for all dai-link */
+	do {
+		struct asoc_simple_data adata;
+		struct device_node *codec;
+		struct device_node *plat;
+		struct device_node *np;
+		int num = of_get_child_count(node);
+
+		/* get codec */
+		codec = of_get_child_by_name(node,
+					     is_top ? PREFIX "codec" : "codec");
+		if (!codec) {
+			ret = -ENODEV;
+			goto error;
+		}
+		/* get platform */
+		plat = of_get_child_by_name(node,
+					    is_top ? PREFIX "plat" : "plat");
+
+		/* get convert-xxx property */
+		memset(&adata, 0, sizeof(adata));
+		for_each_child_of_node (node, np)
+			simple_parse_convert(dev, np, &adata);
+
+		/* loop for all CPU/Codec node */
+		for_each_child_of_node (node, np) {
+			if (plat == np)
+				continue;
+			/*
+			 * It is DPCM
+			 * if it has many CPUs,
+			 * or has convert-xxx property
+			 */
+			if (dpcm_selectable && (num > 2 || adata.convert_rate ||
+						adata.convert_channels)) {
+				/*
+				 * np
+				 *	 |1(CPU)|0(Codec)  li->cpu
+				 * CPU	 |Pass  |return
+				 * Codec |return|Pass
+				 */
+				if (li->cpu != (np == codec))
+					ret = func_dpcm(priv, np, codec, li,
+							is_top);
+				/* else normal sound */
+			} else {
+				/*
+				 * np
+				 *	 |1(CPU)|0(Codec)  li->cpu
+				 * CPU	 |Pass  |return
+				 * Codec |return|return
+				 */
+				if (li->cpu && (np != codec))
+					ret = func_noml(priv, np, codec, li,
+							is_top);
+			}
+
+			if (ret < 0) {
+				of_node_put(codec);
+				of_node_put(np);
+				goto error;
+			}
+		}
+
+		of_node_put(codec);
+		node = of_get_next_child(top, node);
+	} while (!is_top && node);
+
+error:
+	of_node_put(node);
+	return ret;
+}
+
+static int simple_for_each_link(
+	struct asoc_simple_priv *priv, struct link_info *li,
+	int (*func_noml)(struct asoc_simple_priv *priv, struct device_node *np,
+			 struct device_node *codec, struct link_info *li,
+			 bool is_top),
+	int (*func_dpcm)(struct asoc_simple_priv *priv, struct device_node *np,
+			 struct device_node *codec, struct link_info *li,
+			 bool is_top))
+{
+	int ret;
+	/*
+	 * Detect all CPU first, and Detect all Codec 2nd.
+	 *
+	 * In Normal sound case, all DAIs are detected
+	 * as "CPU-Codec".
+	 *
+	 * In DPCM sound case,
+	 * all CPUs   are detected as "CPU-dummy", and
+	 * all Codecs are detected as "dummy-Codec".
+	 * To avoid random sub-device numbering,
+	 * detect "dummy-Codec" in last;
+	 */
+	for (li->cpu = 1; li->cpu >= 0; li->cpu--) {
+		ret = __simple_for_each_link(priv, li, func_noml, func_dpcm);
+		if (ret < 0)
+			break;
+	}
+
+	return ret;
+}
+
+static int simple_parse_of(struct asoc_simple_priv *priv, struct link_info *li)
+{
+	struct snd_soc_card *card = simple_priv_to_card(priv);
+	int ret;
+
+	ret = asoc_simple_parse_widgets(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_routing(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_pin_switches(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	/* Single/Muti DAI link(s) & New style of DT node */
+	memset(li, 0, sizeof(*li));
+	ret = simple_for_each_link(priv, li, simple_dai_link_of,
+				   simple_dai_link_of_dpcm);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_parse_card_name(card, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_of_parse_aux_devs(card, PREFIX "aux-devs");
+
+	return ret;
+}
+
+static int simple_count_noml(struct asoc_simple_priv *priv,
+			     struct device_node *np, struct device_node *codec,
+			     struct link_info *li, bool is_top)
+{
+	if (li->link >= SNDRV_MAX_LINKS) {
+		struct device *dev = simple_priv_to_dev(priv);
+
+		dev_err(dev, "too many links\n");
+		return -EINVAL;
+	}
+
+	li->num[li->link].cpus = 1;
+	li->num[li->link].codecs = 1;
+	li->num[li->link].platforms = 1;
+
+	li->link += 1;
+
+	return 0;
+}
+
+static int simple_count_dpcm(struct asoc_simple_priv *priv,
+			     struct device_node *np, struct device_node *codec,
+			     struct link_info *li, bool is_top)
+{
+	if (li->link >= SNDRV_MAX_LINKS) {
+		struct device *dev = simple_priv_to_dev(priv);
+
+		dev_err(dev, "too many links\n");
+		return -EINVAL;
+	}
+
+	if (li->cpu) {
+		li->num[li->link].cpus = 1;
+		li->num[li->link].platforms = 1;
+
+		li->link++; /* CPU-dummy */
+	} else {
+		li->num[li->link].codecs = 1;
+
+		li->link++; /* dummy-Codec */
+	}
+
+	return 0;
+}
+
+static int simple_get_dais_count(struct asoc_simple_priv *priv,
+				 struct link_info *li)
+{
+	struct device *dev = simple_priv_to_dev(priv);
+	struct device_node *top = dev->of_node;
+
+	/*
+	 * link_num :	number of links.
+	 *		CPU-Codec / CPU-dummy / dummy-Codec
+	 * dais_num :	number of DAIs
+	 * ccnf_num :	number of codec_conf
+	 *		same number for "dummy-Codec"
+	 *
+	 * ex1)
+	 * CPU0 --- Codec0	link : 5
+	 * CPU1 --- Codec1	dais : 7
+	 * CPU2 -/		ccnf : 1
+	 * CPU3 --- Codec2
+	 *
+	 *	=> 5 links = 2xCPU-Codec + 2xCPU-dummy + 1xdummy-Codec
+	 *	=> 7 DAIs  = 4xCPU + 3xCodec
+	 *	=> 1 ccnf  = 1xdummy-Codec
+	 *
+	 * ex2)
+	 * CPU0 --- Codec0	link : 5
+	 * CPU1 --- Codec1	dais : 6
+	 * CPU2 -/		ccnf : 1
+	 * CPU3 -/
+	 *
+	 *	=> 5 links = 1xCPU-Codec + 3xCPU-dummy + 1xdummy-Codec
+	 *	=> 6 DAIs  = 4xCPU + 2xCodec
+	 *	=> 1 ccnf  = 1xdummy-Codec
+	 *
+	 * ex3)
+	 * CPU0 --- Codec0	link : 6
+	 * CPU1 -/		dais : 6
+	 * CPU2 --- Codec1	ccnf : 2
+	 * CPU3 -/
+	 *
+	 *	=> 6 links = 0xCPU-Codec + 4xCPU-dummy + 2xdummy-Codec
+	 *	=> 6 DAIs  = 4xCPU + 2xCodec
+	 *	=> 2 ccnf  = 2xdummy-Codec
+	 *
+	 * ex4)
+	 * CPU0 --- Codec0 (convert-rate)	link : 3
+	 * CPU1 --- Codec1			dais : 4
+	 *					ccnf : 1
+	 *
+	 *	=> 3 links = 1xCPU-Codec + 1xCPU-dummy + 1xdummy-Codec
+	 *	=> 4 DAIs  = 2xCPU + 2xCodec
+	 *	=> 1 ccnf  = 1xdummy-Codec
+	 */
+	if (!top) {
+		li->num[0].cpus = 1;
+		li->num[0].codecs = 1;
+		li->num[0].platforms = 1;
+
+		li->link = 1;
+		return 0;
+	}
+
+	return simple_for_each_link(priv, li, simple_count_noml,
+				    simple_count_dpcm);
+}
+
+static int simple_soc_probe(struct snd_soc_card *card)
+{
+	struct asoc_simple_priv *priv = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	ret = asoc_simple_init_hp(card, &priv->hp_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	ret = asoc_simple_init_mic(card, &priv->mic_jack, PREFIX);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int asoc_simple_probe(struct platform_device *pdev)
+{
+	struct asoc_simple_priv *priv;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct snd_soc_card *card;
+	struct link_info *li;
+	int ret;
+
+	/* Allocate the private data and the DAI link array */
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	card = simple_priv_to_card(priv);
+	card->owner = THIS_MODULE;
+	card->dev = dev;
+	card->probe = simple_soc_probe;
+	card->driver_name = "simple-card";
+
+	li = devm_kzalloc(dev, sizeof(*li), GFP_KERNEL);
+	if (!li)
+		return -ENOMEM;
+
+	ret = simple_get_dais_count(priv, li);
+	if (ret < 0)
+		return ret;
+
+	if (!li->link)
+		return -EINVAL;
+
+	ret = asoc_simple_init_priv(priv, li);
+	if (ret < 0)
+		return ret;
+
+	if (np && of_device_is_available(np)) {
+		ret = simple_parse_of(priv, li);
+		if (ret < 0) {
+			if (ret != -EPROBE_DEFER)
+				dev_err(dev, "parse error %d\n", ret);
+			goto err;
+		}
+
+	} else {
+		struct asoc_simple_card_info *cinfo;
+		struct snd_soc_dai_link_component *cpus;
+		struct snd_soc_dai_link_component *codecs;
+		struct snd_soc_dai_link_component *platform;
+		struct snd_soc_dai_link *dai_link = priv->dai_link;
+		struct simple_dai_props *dai_props = priv->dai_props;
+
+		cinfo = dev->platform_data;
+		if (!cinfo) {
+			dev_err(dev, "no info for asoc-simple-card\n");
+			return -EINVAL;
+		}
+
+		if (!cinfo->name || !cinfo->codec_dai.name || !cinfo->codec ||
+		    !cinfo->platform || !cinfo->cpu_dai.name) {
+			dev_err(dev,
+				"insufficient asoc_simple_card_info settings\n");
+			return -EINVAL;
+		}
+
+		cpus = dai_link->cpus;
+		cpus->dai_name = cinfo->cpu_dai.name;
+
+		codecs = dai_link->codecs;
+		codecs->name = cinfo->codec;
+		codecs->dai_name = cinfo->codec_dai.name;
+
+		platform = dai_link->platforms;
+		platform->name = cinfo->platform;
+
+		card->name = (cinfo->card) ? cinfo->card : cinfo->name;
+		dai_link->name = cinfo->name;
+		dai_link->stream_name = cinfo->name;
+		dai_link->dai_fmt = cinfo->daifmt;
+		dai_link->init = asoc_simple_dai_init;
+		memcpy(dai_props->cpu_dai, &cinfo->cpu_dai,
+		       sizeof(*dai_props->cpu_dai));
+		memcpy(dai_props->codec_dai, &cinfo->codec_dai,
+		       sizeof(*dai_props->codec_dai));
+	}
+
+	snd_soc_card_set_drvdata(card, priv);
+
+	asoc_simple_debug_info(priv);
+
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret < 0)
+		goto err;
+
+	devm_kfree(dev, li);
+	return 0;
+err:
+	asoc_simple_clean_reference(card);
+
+	return ret;
+}
+
+static const struct of_device_id simple_of_match[] = {
+	{
+		.compatible = "simple-audio-card",
+	},
+	{ .compatible = "simple-scu-audio-card",
+	  .data = (void *)DPCM_SELECTABLE },
+	{},
+};
+MODULE_DEVICE_TABLE(of, simple_of_match);
+
+static struct platform_driver asoc_simple_card = {
+	.driver = {
+		.name = "asoc-simple-card",
+		.pm = &snd_soc_pm_ops,
+		.of_match_table = simple_of_match,
+	},
+	.probe = asoc_simple_probe,
+	.remove = asoc_simple_remove,
+};
+
+module_platform_driver(asoc_simple_card);
+
+MODULE_ALIAS("platform:asoc-simple-card");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("ASoC wm8960 Sound Card");
+MODULE_AUTHOR("Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>");
diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c
index 499604f1e178..fbdfd4e0503f 100644
--- a/sound/soc/codecs/wm8960.c
+++ b/sound/soc/codecs/wm8960.c
@@ -405,6 +405,7 @@ SND_SOC_DAPM_PGA("OUT3 VMID", WM8960_POWER2, 1, 0, NULL, 0),
 };
 
 static const struct snd_soc_dapm_route audio_paths[] = {
+	{ "Left Boost Mixer", NULL , "MICB"},
 	{ "Left Boost Mixer", "LINPUT1 Switch", "LINPUT1" },
 	{ "Left Boost Mixer", "LINPUT2 Switch", "LINPUT2" },
 	{ "Left Boost Mixer", "LINPUT3 Switch", "LINPUT3" },
@@ -414,6 +415,7 @@ static const struct snd_soc_dapm_route audio_paths[] = {
 	{ "Left Input Mixer", NULL, "LINPUT2" },
 	{ "Left Input Mixer", NULL, "LINPUT3" },
 
+	{ "Right Boost Mixer", NULL , "MICB"},
 	{ "Right Boost Mixer", "RINPUT1 Switch", "RINPUT1" },
 	{ "Right Boost Mixer", "RINPUT2 Switch", "RINPUT2" },
 	{ "Right Boost Mixer", "RINPUT3 Switch", "RINPUT3" },
@@ -601,158 +603,155 @@ static const int bclk_divs[] = {
 	120, 160, 220, 240, 320, 320, 320
 };
 
-/**
- * wm8960_configure_sysclk - checks if there is a sysclk frequency available
- *	The sysclk must be chosen such that:
- *		- sysclk     = MCLK / sysclk_divs
- *		- lrclk      = sysclk / dac_divs
- *		- 10 * bclk  = sysclk / bclk_divs
- *
- * @wm8960: codec private data
- * @mclk: MCLK used to derive sysclk
- * @sysclk_idx: sysclk_divs index for found sysclk
- * @dac_idx: dac_divs index for found lrclk
- * @bclk_idx: bclk_divs index for found bclk
- *
- * Returns:
- *  -1, in case no sysclk frequency available found
- * >=0, in case we could derive bclk and lrclk from sysclk using
- *      (@sysclk_idx, @dac_idx, @bclk_idx) dividers
- */
-static
-int wm8960_configure_sysclk(struct wm8960_priv *wm8960, int mclk,
-			    int *sysclk_idx, int *dac_idx, int *bclk_idx)
-{
-	int sysclk, bclk, lrclk;
-	int i, j, k;
-	int diff;
-
-	/* marker for no match */
-	*bclk_idx = -1;
-
-	bclk = wm8960->bclk;
-	lrclk = wm8960->lrclk;
-
-	/* check if the sysclk frequency is available. */
-	for (i = 0; i < ARRAY_SIZE(sysclk_divs); ++i) {
-		if (sysclk_divs[i] == -1)
-			continue;
-		sysclk = mclk / sysclk_divs[i];
-		for (j = 0; j < ARRAY_SIZE(dac_divs); ++j) {
-			if (sysclk != dac_divs[j] * lrclk)
-				continue;
-			for (k = 0; k < ARRAY_SIZE(bclk_divs); ++k) {
-				diff = sysclk - bclk * bclk_divs[k] / 10;
-				if (diff == 0) {
-					*sysclk_idx = i;
-					*dac_idx = j;
-					*bclk_idx = k;
-					break;
-				}
-			}
-			if (k != ARRAY_SIZE(bclk_divs))
-				break;
-		}
-		if (j != ARRAY_SIZE(dac_divs))
-			break;
-	}
-	return *bclk_idx;
-}
-
-/**
- * wm8960_configure_pll - checks if there is a PLL out frequency available
- *	The PLL out frequency must be chosen such that:
- *		- sysclk      = lrclk * dac_divs
- *		- freq_out    = sysclk * sysclk_divs
- *		- 10 * sysclk = bclk * bclk_divs
- *
- * 	If we cannot find an exact match for (sysclk, lrclk, bclk)
- * 	triplet, we relax the bclk such that bclk is chosen as the
- * 	closest available frequency greater than expected bclk.
- *
- * @component: component structure
- * @freq_in: input frequency used to derive freq out via PLL
- * @sysclk_idx: sysclk_divs index for found sysclk
- * @dac_idx: dac_divs index for found lrclk
- * @bclk_idx: bclk_divs index for found bclk
- *
- * Returns:
- * < 0, in case no PLL frequency out available was found
- * >=0, in case we could derive bclk, lrclk, sysclk from PLL out using
- *      (@sysclk_idx, @dac_idx, @bclk_idx) dividers
- */
-static
-int wm8960_configure_pll(struct snd_soc_component *component, int freq_in,
-			 int *sysclk_idx, int *dac_idx, int *bclk_idx)
-{
-	struct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);
-	int sysclk, bclk, lrclk, freq_out;
-	int diff, closest, best_freq_out;
-	int i, j, k;
-
-	bclk = wm8960->bclk;
-	lrclk = wm8960->lrclk;
-	closest = freq_in;
-
-	best_freq_out = -EINVAL;
-	*sysclk_idx = *dac_idx = *bclk_idx = -1;
-
-	/*
-	 * From Datasheet, the PLL performs best when f2 is between
-	 * 90MHz and 100MHz, the desired sysclk output is 11.2896MHz
-	 * or 12.288MHz, then sysclkdiv = 2 is the best choice.
-	 * So search sysclk_divs from 2 to 1 other than from 1 to 2.
-	 */
-	for (i = ARRAY_SIZE(sysclk_divs) - 1; i >= 0; --i) {
-		if (sysclk_divs[i] == -1)
-			continue;
-		for (j = 0; j < ARRAY_SIZE(dac_divs); ++j) {
-			sysclk = lrclk * dac_divs[j];
-			freq_out = sysclk * sysclk_divs[i];
-
-			for (k = 0; k < ARRAY_SIZE(bclk_divs); ++k) {
-				if (!is_pll_freq_available(freq_in, freq_out))
-					continue;
-
-				diff = sysclk - bclk * bclk_divs[k] / 10;
-				if (diff == 0) {
-					*sysclk_idx = i;
-					*dac_idx = j;
-					*bclk_idx = k;
-					return freq_out;
-				}
-				if (diff > 0 && closest > diff) {
-					*sysclk_idx = i;
-					*dac_idx = j;
-					*bclk_idx = k;
-					closest = diff;
-					best_freq_out = freq_out;
-				}
-			}
-		}
-	}
+   
+																			
+									   
+									 
+									
+									 
+  
+															 
+															 
+														  
+  
+										  
+									
+												  
+										   
+											
+  
+		   
+												   
+																
+												   
+   
+	  
+																 
+													
+ 
+						 
+			 
+						  
+
+						  
+				
+
+					 
+					   
+
+												  
+												
+						   
+			
+								 
+											  
+									 
+			 
+												
+											 
+					
+					 
+				  
+				   
+		   
+	 
+									 
+					 
+				  
+				   
+					
+	 
+	
+								  
+		  
+   
+								
+		 
+  
+				  
+ 
+
+   
+																		  
+												  
+									
+										
+									
+  
+															  
+															  
+														   
+  
+								  
+															
+												  
+										   
+											
+  
+		   
+														
+																	  
+												   
+   
+	  
+																		  
+												 
+ 
+																	   
+								   
+								  
+			 
+
+					 
+					   
+				   
+
+						 
+										 
+
+												
+						   
+			
+											  
+								
+									  
+
+												
+												  
+			  
+
+											 
+					
+					 
+				  
+				   
+					 
+	 
+									 
+					 
+				  
+				   
+					
+							  
+	 
+	
+   
+  
 
-	return best_freq_out;
-}
+					  
+ 
 static int wm8960_configure_clocking(struct snd_soc_component *component)
 {
 	struct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);
-	int freq_out, freq_in;
+	int sysclk, bclk, lrclk, freq_out, freq_in;
 	u16 iface1 = snd_soc_component_read(component, WM8960_IFACE1);
 	int i, j, k;
-	int ret;
+		 
 
-	/*
-	 * For Slave mode clocking should still be configured,
-	 * so this if statement should be removed, but some platform
-	 * may not work if the sysclk is not configured, to avoid such
-	 * compatible issue, just add '!wm8960->sysclk' condition in
-	 * this if statement.
-	 */
-	if (!(iface1 & (1 << 6)) && !wm8960->sysclk) {
-		dev_warn(component->dev,
-			 "slave mode, but proceeding with no clock configuration\n");
-		return 0;
+	if (!(iface1 & (1<<6))) {
+		dev_dbg(component->dev,
+			"Codec is slave mode, no need to configure clock\n");
+		//return 0;
 	}
 
 	if (wm8960->clk_id != WM8960_SYSCLK_MCLK && !wm8960->freq_in) {
@@ -761,6 +760,11 @@ static int wm8960_configure_clocking(struct snd_soc_component *component)
 	}
 
 	freq_in = wm8960->freq_in;
+	bclk = wm8960->bclk;
+	lrclk = wm8960->lrclk;
+
+	//printk("clk_id %d freq_in: %d bclk: %d  lrclk: %d\n",wm8960->clk_id ,freq_in, bclk,lrclk);
+
 	/*
 	 * If it's sysclk auto mode, check if the MCLK can provide sysclk or
 	 * not. If MCLK can provide sysclk, using MCLK to provide sysclk
@@ -779,21 +783,61 @@ static int wm8960_configure_clocking(struct snd_soc_component *component)
 	}
 
 	if (wm8960->clk_id != WM8960_SYSCLK_PLL) {
-		ret = wm8960_configure_sysclk(wm8960, freq_out, &i, &j, &k);
-		if (ret >= 0) {
+		/* check if the sysclk frequency is available. */
+		for (i = 0; i < ARRAY_SIZE(sysclk_divs); ++i) {
+			if (sysclk_divs[i] == -1)
+				continue;
+			sysclk = freq_out / sysclk_divs[i];
+			for (j = 0; j < ARRAY_SIZE(dac_divs); ++j) {
+				if (sysclk != dac_divs[j] * lrclk)
+					continue;
+				for (k = 0; k < ARRAY_SIZE(bclk_divs); ++k)
+					if (sysclk == bclk * bclk_divs[k] / 10)
+						break;
+				if (k != ARRAY_SIZE(bclk_divs))
+					break;
+			}
+			if (j != ARRAY_SIZE(dac_divs))
+				break;
+		}
+
+		if (i != ARRAY_SIZE(sysclk_divs)) {
 			goto configure_clock;
 		} else if (wm8960->clk_id != WM8960_SYSCLK_AUTO) {
 			dev_err(component->dev, "failed to configure clock\n");
 			return -EINVAL;
 		}
 	}
+	/* get a available pll out frequency and set pll */
+	for (i = 0; i < ARRAY_SIZE(sysclk_divs); ++i) {
+		if (sysclk_divs[i] == -1)
+			continue;
+		for (j = 0; j < ARRAY_SIZE(dac_divs); ++j) {
+			sysclk = lrclk * dac_divs[j];
+			freq_out = sysclk * sysclk_divs[i];
 
-	freq_out = wm8960_configure_pll(component, freq_in, &i, &j, &k);
-	if (freq_out < 0) {
-		dev_err(component->dev, "failed to configure clock via PLL\n");
-		return freq_out;
+			for (k = 0; k < ARRAY_SIZE(bclk_divs); ++k) {
+				if (sysclk == bclk * bclk_divs[k] / 10 &&
+				    is_pll_freq_available(freq_in, freq_out)) {
+					wm8960_set_pll(component,
+						       freq_in, freq_out);
+					break;
+				} else {
+					continue;
+				}
+			}
+			if (k != ARRAY_SIZE(bclk_divs))
+				break;
+		}
+		if (j != ARRAY_SIZE(dac_divs))
+			break;
 	}
-	wm8960_set_pll(component, freq_in, freq_out);
+
+	if (i == ARRAY_SIZE(sysclk_divs)) {
+		dev_err(component->dev, "failed to configure clock\n");
+		return -EINVAL;
+	}
+											  
 
 configure_clock:
 	/* configure sysclk clock */
@@ -1287,6 +1331,7 @@ static int wm8960_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 {
 	struct snd_soc_component *component = dai->component;
 	struct wm8960_priv *wm8960 = snd_soc_component_get_drvdata(component);
+	clk_id = WM8960_SYSCLK_PLL;
 
 	switch (clk_id) {
 	case WM8960_SYSCLK_MCLK:
@@ -1303,6 +1348,7 @@ static int wm8960_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,
 		return -EINVAL;
 	}
 
+	wm8960->freq_in = 24000000;
 	wm8960->sysclk = freq;
 	wm8960->clk_id = clk_id;
 
@@ -1368,7 +1414,6 @@ static const struct snd_soc_component_driver soc_component_dev_wm8960 = {
 	.idle_bias_on		= 1,
 	.use_pmdown_time	= 1,
 	.endianness		= 1,
-	.non_legacy_dai_naming	= 1,
 };
 
 static const struct regmap_config wm8960_regmap = {
@@ -1393,12 +1438,6 @@ static void wm8960_set_pdata_from_of(struct i2c_client *i2c,
 
 	if (of_property_read_bool(np, "wlf,shared-lrclk"))
 		pdata->shared_lrclk = true;
-
-	of_property_read_u32_array(np, "wlf,gpio-cfg", pdata->gpio_cfg,
-				   ARRAY_SIZE(pdata->gpio_cfg));
-
-	of_property_read_u32_array(np, "wlf,hp-cfg", pdata->hp_cfg,
-				   ARRAY_SIZE(pdata->hp_cfg));
 }
 
 static int wm8960_i2c_probe(struct i2c_client *i2c,
@@ -1413,6 +1452,7 @@ static int wm8960_i2c_probe(struct i2c_client *i2c,
 	if (wm8960 == NULL)
 		return -ENOMEM;
 
+	wm8960->clk_id = WM8960_SYSCLK_PLL;
 	wm8960->mclk = devm_clk_get(&i2c->dev, "mclk");
 	if (IS_ERR(wm8960->mclk)) {
 		if (PTR_ERR(wm8960->mclk) == -EPROBE_DEFER)
@@ -1456,20 +1496,6 @@ static int wm8960_i2c_probe(struct i2c_client *i2c,
 	regmap_update_bits(wm8960->regmap, WM8960_LOUT2, 0x100, 0x100);
 	regmap_update_bits(wm8960->regmap, WM8960_ROUT2, 0x100, 0x100);
 
-	/* ADCLRC pin configured as GPIO. */
-	regmap_update_bits(wm8960->regmap, WM8960_IFACE2, 1 << 6,
-			   wm8960->pdata.gpio_cfg[0] << 6);
-	regmap_update_bits(wm8960->regmap, WM8960_ADDCTL4, 0xF << 4,
-			   wm8960->pdata.gpio_cfg[1] << 4);
-
-	/* Enable headphone jack detect */
-	regmap_update_bits(wm8960->regmap, WM8960_ADDCTL4, 3 << 2,
-			   wm8960->pdata.hp_cfg[0] << 2);
-	regmap_update_bits(wm8960->regmap, WM8960_ADDCTL2, 3 << 5,
-			   wm8960->pdata.hp_cfg[1] << 5);
-	regmap_update_bits(wm8960->regmap, WM8960_ADDCTL1, 3,
-			   wm8960->pdata.hp_cfg[2]);
-
 	i2c_set_clientdata(i2c, wm8960);
 
 	ret = devm_snd_soc_register_component(&i2c->dev,
diff --git a/sound/soc/codecs/wm8960.h b/sound/soc/codecs/wm8960.h
index 63ba6c03c488..ab3220d3411d 100644
--- a/sound/soc/codecs/wm8960.h
+++ b/sound/soc/codecs/wm8960.h
@@ -1,6 +1,9 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * wm8960.h  --  WM8960 Soc Audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #ifndef _WM8960_H
-- 
2.45.2

